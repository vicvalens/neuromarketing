<!DOCTYPE html>
<html lang="es">
  <head>
    <meta charset="utf-8" />
    <title>Heatmap con datos reales (clics)</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <script src="https://aframe.io/releases/1.7.1/aframe.min.js"></script>

    <script>
      AFRAME.registerComponent('click-heatmap', {
        schema: {
          size: {type: 'int', default: 512},
          pointRadius: {type: 'number', default: 25}
        },

        init: function () {
          const size = this.data.size;
          const canvas = this.canvas = document.createElement('canvas');
          canvas.width = canvas.height = size;
          this.ctx = canvas.getContext('2d');

          // fondo oscuro
          this.ctx.fillStyle = 'black';
          this.ctx.fillRect(0, 0, size, size);

          this.texture = new THREE.CanvasTexture(canvas);
          this.texture.needsUpdate = true;

          // aplicar textura cuando el modelo cargue
          this.onModelLoaded = this.onModelLoaded.bind(this);
          this.el.addEventListener('model-loaded', this.onModelLoaded);

          // manejar clics reales
          this.onClick = this.onClick.bind(this);
          this.el.addEventListener('click', this.onClick);
        },

        onModelLoaded: function () {
          const mesh = this.el.getObject3D('mesh');
          if (!mesh) return;

          mesh.traverse(node => {
            if (node.isMesh) {
              node.userData.originalMap = node.material.map;
              node.material.map = this.texture;
              node.material.needsUpdate = true;
            }
          });
        },

        onClick: function (evt) {
          const intersection = evt.detail.intersection;
          if (!intersection || !intersection.uv) return;

          const uv = intersection.uv; // THREE.Vector2 (x,y 0–1)
          const w = this.canvas.width;
          const h = this.canvas.height;

          const x = uv.x * w;
          const y = (1 - uv.y) * h;  // invertimos Y

          this.addHeatPoint(x, y);
          this.texture.needsUpdate = true;
        },

        addHeatPoint: function (x, y) {
          const ctx = this.ctx;
          const r = this.data.pointRadius;

          const grd = ctx.createRadialGradient(x, y, 0, x, y, r);
          grd.addColorStop(0.0, 'rgba(255,255,255,1)');
          grd.addColorStop(0.3, 'rgba(255,255,0,1)');
          grd.addColorStop(0.6, 'rgba(255,128,0,0.9)');
          grd.addColorStop(1.0, 'rgba(255,0,0,0)');

          ctx.fillStyle = grd;
          ctx.fillRect(x - r, y - r, r * 2, r * 2);
        }
      });
    </script>
  </head>

  <body>
    <a-scene background="color: #222">
      <a-assets>
        <!-- tu modelo -->
        <a-asset-item id="modelo" src="model2.glb"></a-asset-item>
      </a-assets>

      <!-- Cámara + cursor basado en mouse -->
      <a-entity camera look-controls position="0 1.6 0">
        <a-entity cursor="rayOrigin: mouse"
                  raycaster="objects: .heatmap-target"></a-entity>
      </a-entity>

      <!-- Modelo con el componente de heatmap real -->
      <a-entity gltf-model="#modelo"
                class="heatmap-target"
                position="0 1.5 -2"
                rotation="0 45 0"
                click-heatmap="size: 512; pointRadius: 30">
      </a-entity>
    </a-scene>
  </body>
</html>
